import { OperatorFunction, Observable, SchedulerLike, asyncScheduler, ObservableInput, Operator, Subscriber, TeardownLogic, SchedulerAction } from "rxjs";
import { OuterSubscriber } from "rxjs/internal/OuterSubscriber";

export function isDate(value: any): value is Date {
  return value instanceof Date && !isNaN(+value);
}
export function timeOutMonitor<T,R>(due:number|Date, startSelector:(T)=>boolean, stopSelector:(start:T,current:T)=>boolean, withObservable:(start:T)=>ObservableInput<T|R>,scheduler:SchedulerLike = asyncScheduler):OperatorFunction<T,T|R> {

  return (source: Observable<T>) => {
    let absoluteTimeout = isDate(due);
    let waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(<number>due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout,startSelector,stopSelector, withObservable, scheduler));
  };
}

class TimeoutWithOperator<T> implements Operator<T, T> {
  constructor(private waitFor: number,
              private absoluteTimeout: boolean,
              private startSelector:(T)=>boolean,private stopSelector:(start:T,current:T)=>boolean,private withObservable:(start:T)=>ObservableInput<T>,
              private scheduler: SchedulerLike) {
  }
  call(subscriber: Subscriber<T>, source: any): TeardownLogic {
    return source.subscribe(new TimeoutWithSubscriber(
      subscriber, this.absoluteTimeout, this.waitFor,this.startSelector,this.stopSelector, this.withObservable, this.scheduler
    ));
  }
}

class TimeoutWithSubscriber<T, R> extends OuterSubscriber<T, R> {

  private action: SchedulerAction<TimeoutWithSubscriber<T, R>> = null;

  constructor(destination: Subscriber<T>,
              private absoluteTimeout: boolean,
              private waitFor: number,
              private startSelector:(T)=>boolean,private stopSelector:(start:T,current:T)=>boolean,private withObservable:(start:T)=>ObservableInput<T>,
              private scheduler: SchedulerLike) {
    super(destination);
    this.scheduleTimeout();
  }

  private static dispatchTimeout<T, R>(subscriber: TimeoutWithSubscriber<T, R>): void {
    const { withObservable } = subscriber;
    (<any> subscriber)._unsubscribeAndRecycle();
    subscriber.add(subscribeToResult(subscriber, withObservable));
  }

  private scheduleTimeout(): void {
    const { action } = this;
    if (action) {
      // Recycle the action if we've already scheduled one. All the production
      // Scheduler Actions mutate their state/delay time and return themeselves.
      // VirtualActions are immutable, so they create and return a clone. In this
      // case, we need to set the action reference to the most recent VirtualAction,
      // to ensure that's the one we clone from next time.
      this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> action.schedule(this, this.waitFor));
    } else {
      this.add(this.action = (<SchedulerAction<TimeoutWithSubscriber<T, R>>> this.scheduler.schedule<TimeoutWithSubscriber<T, R>>(
        TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this
      )));
    }
  }

  protected _next(value: T): void {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }
    super._next(value);
  }

  /** @deprecated This is an internal implementation detail, do not use. */
  _unsubscribe() {
    this.action = null;
    this.scheduler = null;
    this.withObservable = null;
  }
}
